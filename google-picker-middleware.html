<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>Google Picker</title>
    <style>
      html, body {
            margin: 0;
            padding: 0;
        height: 100%;
        width: 100%;
        background-color: #000000;
        font-family: "Inter", "SF Pro Text", "SFProText", "Helvetica Neue", Arial, sans-serif;
        color: #f3f4f6;
        overflow: hidden;
        /* Support for iOS safe areas */
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      }
      #picker-root {
        height: 100%;
      }
      #loader {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        background: rgba(0, 0, 0, 0.9);
        z-index: 10;
        transition: opacity 180ms ease;
        /* Support for iOS safe areas */
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      }
      #loader.hidden {
        opacity: 0;
        pointer-events: none;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border-radius: 999px;
        border: 4px solid rgba(79, 70, 229, 0.25);
        border-top-color: #4d65ff;
        animation: spin 1s linear infinite;
        margin-bottom: 16px;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      #loader > div:last-child {
        font-size: 15px;
        color: #f3f4f6;
        line-height: 1.5;
      }
      #error-banner {
        position: absolute;
        top: 12px;
        left: 12px;
        right: 12px;
        padding: 14px 16px;
        border-radius: 12px;
        background: rgba(239, 68, 68, 0.12);
        color: #fca5a5;
        border: 1px solid rgba(239, 68, 68, 0.25);
        font-size: 15px;
        line-height: 1.5;
        display: none;
        z-index: 20;
        /* Support for iOS safe areas */
        top: calc(12px + env(safe-area-inset-top));
        left: calc(12px + env(safe-area-inset-left));
        right: calc(12px + env(safe-area-inset-right));
      }
      #error-banner.visible {
        display: block;
      }
      #signin-overlay {
        position: absolute;
        inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        background: rgba(0, 0, 0, 0.88);
        z-index: 30;
        padding: 24px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 160ms ease;
        /* Support for iOS safe areas */
        padding: calc(24px + env(safe-area-inset-top)) calc(24px + env(safe-area-inset-right)) calc(24px + env(safe-area-inset-bottom)) calc(24px + env(safe-area-inset-left));
      }
      #signin-overlay.visible {
        opacity: 1;
        pointer-events: auto;
      }
      #signin-card {
        width: 100%;
        max-width: 360px;
        border-radius: 18px;
        background: #0a0a0a;
        border: 1px solid rgba(31, 31, 31, 0.85);
        padding: 28px 24px;
        box-shadow: 0 32px 120px rgba(0, 0, 0, 0.45);
            text-align: center;
      }
      #signin-card h2 {
        margin: 0 0 12px;
        font-size: 20px;
        font-weight: 700;
        color: #f3f4f6;
        line-height: 1.4;
      }
      #signin-card p {
        margin: 0 0 18px;
        font-size: 14px;
        line-height: 1.6;
        color: #9ca3af;
      }
      #signin-button {
        display: flex;
        justify-content: center;
        margin-bottom: 18px;
        min-height: 44px;
        align-items: center;
      }
      #signin-button > * {
        min-height: 44px;
      }
      #signin-status {
        margin-top: 14px;
        font-size: 13px;
        line-height: 1.5;
        color: #9ca3af;
        }

      #selection-status {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: #f3f4f6;
        padding: 12px 20px;
        border-radius: 24px;
        font-size: 14px;
        font-weight: 500;
        border: 1px solid rgba(79, 70, 229, 0.3);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      #selection-status.visible {
        opacity: 1;
        pointer-events: auto;
      }

      #selection-status .count {
        color: #4d65ff;
        font-weight: 600;
      }

      #selection-status .icon {
        font-size: 16px;
      }

      #picker-controls {
        position: fixed;
        top: calc(12px + env(safe-area-inset-top));
        right: calc(12px + env(safe-area-inset-right));
        z-index: 1001;
        display: flex;
        flex-direction: column;
        gap: 8px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      #picker-controls.visible {
        opacity: 1;
        pointer-events: auto;
      }

      .picker-control-btn {
        background: rgba(0, 0, 0, 0.9);
        color: #f3f4f6;
        border: 1px solid rgba(79, 70, 229, 0.4);
        border-radius: 12px;
        padding: 10px 16px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        min-width: 160px;
        justify-content: center;
      }

      .picker-control-btn:hover {
        background: rgba(79, 70, 229, 0.2);
        border-color: rgba(79, 70, 229, 0.6);
        transform: translateY(-1px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }

      .picker-control-btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .picker-control-btn .icon {
        font-size: 16px;
      }

      .picker-control-btn .text {
        flex: 1;
        text-align: center;
      }

      .picker-control-btn.loading {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
      }

      .picker-control-btn.loading .icon {
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      /* Mobile optimizations */
      @media (max-width: 768px) {
        html, body {
          font-size: 16px;
        }
        
        #loader {
          padding: 16px;
        }
        
        .spinner {
          width: 48px;
          height: 48px;
          border-width: 5px;
          margin-bottom: 20px;
        }
        
        #loader > div:last-child {
          font-size: 16px;
          padding: 0 20px;
          text-align: center;
        }
        
        #error-banner {
          top: calc(8px + env(safe-area-inset-top));
          left: calc(8px + env(safe-area-inset-left));
          right: calc(8px + env(safe-area-inset-right));
          padding: 16px;
          font-size: 14px;
          line-height: 1.5;
          border-radius: 10px;
        }
        
        #signin-overlay {
          padding: calc(16px + env(safe-area-inset-top)) calc(16px + env(safe-area-inset-right)) calc(16px + env(safe-area-inset-bottom)) calc(16px + env(safe-area-inset-left));
        }
        
        #signin-card {
          max-width: calc(100% - 32px);
          padding: 20px 16px;
          border-radius: 16px;
          margin: 0 auto;
        }
        
        #signin-card h2 {
          font-size: 22px;
          margin: 0 0 14px;
          line-height: 1.3;
        }
        
        #signin-card p {
          font-size: 15px;
          margin: 0 0 20px;
          line-height: 1.6;
        }
        
        #signin-button {
          margin-bottom: 20px;
          min-height: 48px;
        }
        
        #signin-button > * {
          min-height: 48px;
          min-width: 44px;
        }
        
        #signin-status {
          font-size: 14px;
          margin-top: 16px;
          line-height: 1.5;
          padding: 0 4px;
        }

        #selection-status {
          bottom: calc(16px + env(safe-area-inset-bottom));
          padding: 14px 24px;
          font-size: 15px;
          border-radius: 28px;
          transform: translateX(-50%) scale(0.95);
          transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #selection-status.visible {
          transform: translateX(-50%) scale(1);
        }

        #picker-controls {
          top: calc(8px + env(safe-area-inset-top));
          right: calc(8px + env(safe-area-inset-right));
          gap: 6px;
        }

        .picker-control-btn {
          padding: 12px 14px;
          font-size: 13px;
          min-width: 140px;
          border-radius: 10px;
        }

        .picker-control-btn .icon {
          font-size: 14px;
        }
      }
      
      /* Extra small mobile devices */
      @media (max-width: 375px) {
        #signin-card {
          padding: 18px 14px;
          border-radius: 14px;
        }
        
        #signin-card h2 {
          font-size: 20px;
          margin: 0 0 12px;
        }
        
        #signin-card p {
          font-size: 14px;
          margin: 0 0 18px;
        }
        
        #error-banner {
          padding: 14px;
          font-size: 13px;
        }
      }
    </style>
    <script>
      // Get configuration from URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const PICKER_CONFIG = {
        apiKey: urlParams.get('api_key') || null,
        clientId: urlParams.get('client_id') || null,
        accessToken: urlParams.get('token') || null,
        locale: (urlParams.get('locale') || 'en').replace('_', '-'),
        // Mode: 'folders' for folder selection, 'files' for audio file selection
        mode: urlParams.get('mode') || 'files',
        // Optional: parent folder ID to start browsing from
        parentFolderId: urlParams.get('parent') || null,
      };
      
      const callbackUrl = urlParams.get('callback') || 'ezgy://googlepicker';
      const signInElements = { overlay: null, buttonContainer: null, status: null };
      let gisButtonReady = false;
      let signInHandlerBound = false;
      let selectionStatusTimeout;

      function ensureSignInElements() {
        if (!signInElements.overlay) {
          signInElements.overlay = document.getElementById('signin-overlay');
          signInElements.buttonContainer = document.getElementById('signin-button');
          signInElements.status = document.getElementById('signin-status');
        }
        return signInElements;
      }

      function setSignInStatus(message) {
        const { status } = ensureSignInElements();
        if (status) {
          status.textContent = message || '';
        }
      }

      function showSignInOverlay(message) {
        const { overlay } = ensureSignInElements();
        if (overlay) {
          overlay.classList.add('visible');
        }
        if (message !== undefined) {
          setSignInStatus(message);
        }
      }

      function hideSignInOverlay() {
        const { overlay } = ensureSignInElements();
        if (overlay) {
          overlay.classList.remove('visible');
        }
        setSignInStatus('');
      }

      function handleSignInClick() {
        setSignInStatus('Waiting for Google authentication‚Ä¶');
      }

      function handleCredentialResponse(response) {
        if (!response || !response.credential) {
          showSignInOverlay('Sign-in was cancelled. Try again.');
          return;
        }
        setSignInStatus('Opening Google Picker‚Ä¶');
        // After sign-in, we still need to use the access token from the app
        // The sign-in button is mainly for verification/fallback
        beginPickerFlow();
      }

      function initializeSignInButton() {
        const { buttonContainer } = ensureSignInElements();
        if (!buttonContainer) {
          return;
        }
        if (!window.google || !google.accounts || !google.accounts.id) {
          return;
        }
        if (!gisButtonReady && PICKER_CONFIG.clientId) {
          google.accounts.id.initialize({
            client_id: PICKER_CONFIG.clientId,
            callback: handleCredentialResponse,
            auto_select: false,
          });
          google.accounts.id.renderButton(buttonContainer, {
            theme: 'outline',
            size: 'large',
            type: 'standard',
          });
          gisButtonReady = true;
        }
        if (!signInHandlerBound && buttonContainer) {
          buttonContainer.addEventListener('click', handleSignInClick);
          signInHandlerBound = true;
        }
        setSignInStatus('Choose your Google account to continue.');
      }

      function beginPickerFlow() {
        // If we have an access token, proceed directly
        if (PICKER_CONFIG.accessToken && PICKER_CONFIG.accessToken.length >= 10) {
          hideSignInOverlay();
          loadPickerScript();
                    } else {
          // Show sign-in overlay if no token
          showSignInOverlay('Please sign in to access Google Drive.');
          initializeSignInButton();
        }
      }

      function resolveCallbackTarget(status, payload) {
        if (!callbackUrl) {
          return null;
        }

        try {
          // Handle both deep link format (ezgy://googlepicker) and callback URL format
          if (callbackUrl.startsWith('ezgy://')) {
            // Legacy format: ezgy://googlepicker?action=picked&count=N&id_0=...&name_0=...
            const target = new URL(callbackUrl);
            const params = target.searchParams;
            
            if (status === 'selected') {
              // Handle multiple folders from payload
              if (payload.folders && Array.isArray(payload.folders)) {
                // Multiple folders format
                params.set('action', 'picked');
                params.set('count', payload.folders.length.toString());
                payload.folders.forEach((folder, index) => {
                  params.set('id_' + index, folder.id);
                  if (folder.name) {
                    params.set('name_' + index, encodeURIComponent(folder.name));
                  }
                });
              } else if (payload.docId) {
                // Single folder format (backward compatibility)
                params.set('action', 'picked');
                params.set('count', '1');
                params.set('id_0', payload.docId);
                if (payload.docName) {
                  params.set('name_0', encodeURIComponent(payload.docName));
                }
              }
            } else if (status === 'cancel') {
              params.set('action', 'cancelled');
            } else if (status === 'error') {
              params.set('action', 'error');
              if (payload.errorMessage) {
                params.set('message', payload.errorMessage);
              }
            }
            
            return target.toString();
          } else {
            // New callback URL format: callback?pickerStatus=selected&docId=...
            const target = new URL(callbackUrl);
            const params = target.searchParams;
            params.set('pickerSource', 'google-picker');
            params.set('pickerStatus', status);
            
            if (status === 'selected' && payload.folders && Array.isArray(payload.folders)) {
              // Multiple folders: use indexed parameters
              params.set('count', payload.folders.length.toString());
              payload.folders.forEach((folder, index) => {
                params.set('docId_' + index, folder.id);
                if (folder.name) {
                  params.set('docName_' + index, encodeURIComponent(folder.name));
                }
              });
            } else {
              // Single folder or other status: use standard format
              Object.entries(payload || {}).forEach(([key, value]) => {
                if (value !== undefined && value !== null) {
                  if (Array.isArray(value)) {
                    // Handle arrays by creating indexed parameters
                    value.forEach((item, index) => {
                      if (typeof item === 'object') {
                        Object.entries(item).forEach(([subKey, subValue]) => {
                          params.set(`${key}_${index}_${subKey}`, subValue);
                        });
                      } else {
                        params.set(`${key}_${index}`, item);
                      }
                    });
                  } else {
                    params.set(key, value);
                  }
                }
              });
            }
            return target.toString();
          }
        } catch (error) {
          console.error('Failed to resolve callback target:', error);
          return null;
        }
      }

      function completeFlow(status, payload) {
        const targetUrl = resolveCallbackTarget(status, payload);
        if (!targetUrl) {
          if (status === 'error') {
            hideLoader();
            showSignInOverlay(payload?.errorMessage ? decodeURIComponent(payload.errorMessage) : undefined);
            initializeSignInButton();
          }
          return;
        }

        window.location.href = targetUrl;
      }

      function sendMessage(message) {
        const payload = JSON.stringify(message);
        if (window.ReactNativeWebView && typeof window.ReactNativeWebView.postMessage === 'function') {
          window.ReactNativeWebView.postMessage(payload);
        } else if (window.parent && window.parent !== window) {
          window.parent.postMessage(payload, '*');
        } else {
          console.log('Picker message', message);
        }
      }

      function showError(message) {
        const banner = document.getElementById('error-banner');
        if (banner) {
          banner.textContent = message;
          banner.classList.add('visible');
        }
      }

      function hideLoader() {
        const loader = document.getElementById('loader');
        if (loader) {
          loader.classList.add('hidden');
          setTimeout(() => loader.remove(), 220);
        }
      }

      function showSelectionStatus(count, message) {
        const status = document.getElementById('selection-status');
        if (status && count > 0) {
          status.innerHTML = `
            <span class="icon">üéµ</span>
            <span class="count">${count}</span> ${message}
          `;
          status.classList.add('visible');

          // Auto-hide after 3 seconds
          clearTimeout(selectionStatusTimeout);
          selectionStatusTimeout = setTimeout(() => {
            hideSelectionStatus();
          }, 3000);
        }
      }

      function hideSelectionStatus() {
        const status = document.getElementById('selection-status');
        if (status) {
          status.classList.remove('visible');
        }
        clearTimeout(selectionStatusTimeout);
      }

      function updateSelectionStatus(count) {
        if (count === 0) {
          hideSelectionStatus();
        } else {
          const message = count === 1 ? 'file selected' : 'files selected';
          showSelectionStatus(count, message);
        }
      }

      function handlePickerError(message) {
        showError(message);
        showSignInOverlay(message);
        initializeSignInButton();
      }
    
      function pickerCallback(data) {
        if (!data) {
            return;
        }

        const action = data[google.picker.Response.ACTION];
        if (action === google.picker.Action.PICKED) {
          const docs = data[google.picker.Response.DOCUMENTS] || [];

          console.log('üìã Google Picker returned', docs.length, 'document(s)');

          if (PICKER_CONFIG.mode === 'files') {
            // File selection mode - handle audio files
            const files = [];
            const skippedFiles = [];
            const audioMimeTypes = [
              'audio/mpeg', 'audio/mp4', 'audio/x-m4a', 'audio/wav', 'audio/x-wav',
              'audio/flac', 'audio/x-flac', 'audio/aac', 'audio/ogg', 'audio/aiff', 'audio/x-aiff'
            ];

            for (let i = 0; i < docs.length; i++) {
              const doc = docs[i];
              const mimeType = doc[google.picker.Document.MIME_TYPE];
              const name = doc[google.picker.Document.NAME] || '';

              // Accept any audio file or files that look like audio based on extension
              const isAudio = audioMimeTypes.includes(mimeType) ||
                             mimeType.startsWith('audio/') ||
                             /\.(mp3|m4a|wav|flac|aac|ogg|aiff)$/i.test(name);

              if (isAudio) {
                const parentId = doc[google.picker.Document.PARENT_ID] || null;
                files.push({
                  id: doc[google.picker.Document.ID],
                  name: name,
                  mimeType: mimeType,
                  parentId: parentId
                });
                
                // Track the parent folder ID for "Select All" functionality
                if (parentId && parentId !== 'root') {
                  currentFolderId = parentId;
                  console.log('üìÇ Tracked parent folder:', parentId);
                  updateSelectAllButtonText();
                }
                
                console.log('‚úÖ Added audio file:', name, '(ID:', doc[google.picker.Document.ID], ')');
              } else {
                skippedFiles.push({
                  name: name,
                  mimeType: mimeType
                });
                console.log('‚è≠Ô∏è Skipped non-audio file:', name, '(MIME:', mimeType, ')');
              }
            }

            console.log('üìä Selection summary:');
            console.log('  - Total documents selected:', docs.length);
            console.log('  - Audio files found:', files.length);
            console.log('  - Non-audio files skipped:', skippedFiles.length);

            // Show selection status to user
            showSelectionStatus(files.length, files.length === 1 ? 'audio file selected' : 'audio files selected');

            if (files.length > 0) {
              // Warn if many files selected (potential URL length issues)
              if (files.length > 50) {
                console.warn('‚ö†Ô∏è Large selection detected (' + files.length + ' files). URL may be truncated.');
              }

              if (callbackUrl.startsWith('ezgy://')) {
                const target = new URL(callbackUrl);
                const params = target.searchParams;
                params.set('action', 'files_picked');
                params.set('count', files.length.toString());

                files.forEach((file, index) => {
                  params.set('id_' + index, file.id);
                  if (file.name) {
                    params.set('name_' + index, encodeURIComponent(file.name));
                  }
                  if (file.mimeType) {
                    params.set('mime_' + index, file.mimeType);
                  }
                  if (file.parentId) {
                    params.set('parent_' + index, file.parentId);
                  }
                });

                const finalUrl = target.toString();
                console.log('üîµ Redirecting to deep link:', finalUrl);
                console.log('üîµ Audio files selected:', files.length, '- URL length:', finalUrl.length, 'chars');

                // Check for URL length limits (iOS deep links have ~2KB limit)
                const maxUrlLength = 1800; // Conservative limit for iOS deep links
                if (finalUrl.length > maxUrlLength) {
                  console.error('‚ùå URL too long (' + finalUrl.length + ' chars, limit: ' + maxUrlLength + ')');
                  const errorMsg = 'Too many files selected. Please select fewer files (maximum ~' + Math.floor(maxUrlLength / 100) + ' files).';
                  handlePickerError(errorMsg);
                  completeFlow('error', { errorMessage: encodeURIComponent(errorMsg) });
                  return;
                }

                try {
                  window.location.href = finalUrl;
                  setTimeout(function() {
                    if (document.visibilityState === 'visible') {
                      window.open(finalUrl, '_self');
                    }
                  }, 100);
                } catch (error) {
                  console.error('‚ùå Error triggering deep link:', error);
                  try {
                    window.location.replace(finalUrl);
                  } catch (e) {
                    console.error('‚ùå Failed to trigger deep link:', e);
                  }
                }
              } else {
                completeFlow('selected', {
                  files: files,
                  count: files.length,
                  skippedCount: skippedFiles.length
                });
              }
            } else {
              const message = 'No audio files selected. Please select music files (MP3, M4A, WAV, FLAC, etc.).';
              console.warn('‚ö†Ô∏è', message);
              console.log('Available file types in selection:', skippedFiles.map(f => f.name + ' (' + f.mimeType + ')'));
              handlePickerError(message);
              completeFlow('error', { errorMessage: encodeURIComponent(message) });
            }
          } else {
            // Folder selection mode (legacy)
            const folders = [];
            
            for (let i = 0; i < docs.length; i++) {
              const doc = docs[i];
              if (doc[google.picker.Document.MIME_TYPE] === 'application/vnd.google-apps.folder') {
                folders.push({
                  id: doc[google.picker.Document.ID],
                  name: doc[google.picker.Document.NAME] || null
                });
              }
            }
            
            if (folders.length > 0) {
              if (callbackUrl.startsWith('ezgy://')) {
                const target = new URL(callbackUrl);
                const params = target.searchParams;
                params.set('action', 'picked');
                params.set('count', folders.length.toString());
                  
                folders.forEach((folder, index) => {
                  params.set('id_' + index, folder.id);
                  if (folder.name) {
                    params.set('name_' + index, encodeURIComponent(folder.name));
                  }
                });
                
                const finalUrl = target.toString();
                console.log('üîµ Redirecting to deep link:', finalUrl);
                console.log('üîµ Folders selected:', folders.length);
                
                try {
                  window.location.href = finalUrl;
                  setTimeout(function() {
                    if (document.visibilityState === 'visible') {
                      window.open(finalUrl, '_self');
                    }
                  }, 100);
                } catch (error) {
                  console.error('‚ùå Error triggering deep link:', error);
                  try {
                    window.location.replace(finalUrl);
                  } catch (e) {
                    console.error('‚ùå Failed to trigger deep link:', e);
                  }
                }
              } else {
                completeFlow('selected', {
                  folders: folders.map(f => ({ id: f.id, name: f.name })),
                  count: folders.length
                });
              }
            } else {
              handlePickerError('No folders selected. Please select at least one folder.');
              completeFlow('error', { errorMessage: encodeURIComponent('No folders selected') });
            }
          }
        } else if (action === google.picker.Action.CANCEL) {
          sendMessage({ type: 'picker:cancel' });
          completeFlow('cancel', {});
        }
      }

      function enforceFullScreen() {
        const overlays = document.getElementsByClassName('picker-dialog');
        for (const overlay of overlays) {
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.left = '0';
          overlay.style.top = '0';
          overlay.style.maxWidth = '100%';
          overlay.style.maxHeight = '100%';
        }
      }

      function createPicker() {
        try {
          if (!PICKER_CONFIG.apiKey) {
            throw new Error('API key is required for Google Picker');
          }
          
          if (!PICKER_CONFIG.accessToken || PICKER_CONFIG.accessToken.length < 10) {
            throw new Error('Access token is required');
          }

          let view;
          
          if (PICKER_CONFIG.mode === 'files') {
            // Audio file selection mode - show audio files for direct selection
            // This grants drive.file access to the selected files
            // Note: We use ViewId.DOCS to show all files and allow navigation
            // The MIME type filter is applied client-side after selection
            // because Google Picker's setMimeTypes can be unreliable for audio files
            view = new google.picker.DocsView(google.picker.ViewId.DOCS)
              .setIncludeFolders(true)  // Allow navigating into folders
              .setSelectFolderEnabled(false)  // But don't allow selecting folders
              .setEnableDrives(true);  // Enable Shared Drives support
            
            // If a parent folder is specified, start from there
            if (PICKER_CONFIG.parentFolderId) {
              view.setParent(PICKER_CONFIG.parentFolderId);
            }
          } else {
            // Folder selection mode (legacy)
            view = new google.picker.DocsView(google.picker.ViewId.FOLDERS)
              .setIncludeFolders(true)
              .setSelectFolderEnabled(true)
              .setMimeTypes('application/vnd.google-apps.folder')
              .setEnableDrives(true);  // Enable Shared Drives support
          }

          const builder = new google.picker.PickerBuilder()
            .setDeveloperKey(PICKER_CONFIG.apiKey)
            .setOAuthToken(PICKER_CONFIG.accessToken)
            .setLocale(PICKER_CONFIG.locale)
            .addView(view)
            .setSize(window.innerWidth, window.innerHeight)
            .setCallback(pickerCallback)
            .enableFeature(google.picker.Feature.NAV_HIDDEN)
            .enableFeature(google.picker.Feature.SUPPORT_DRIVES)  // Enable Shared Drives support
            .enableFeature(google.picker.Feature.MULTISELECT_ENABLED);

          const picker = builder.build();
          picker.setVisible(true);
          hideLoader();
          enforceFullScreen();
          
          // Show picker controls after a short delay to ensure picker is rendered
          setTimeout(() => {
            if (PICKER_CONFIG.mode === 'files') {
              showPickerControls();
              // Try to detect folder navigation
              detectFolderNavigation();
            }
          }, 500);
          
          return true;
        } catch (error) {
          console.error('Failed to create Google Picker', error);
          const encodedMessage = encodeURIComponent('Unable to initialize Google Picker: ' + error.message);
          handlePickerError('Unable to initialize Google Picker: ' + error.message);
          completeFlow('error', { errorMessage: encodedMessage });
          return false;
        }
      }

      function maybeCreatePicker() {
        if (pickerInitialized) {
          return;
        }
        if (!pickerModuleReady || !PICKER_CONFIG.accessToken) {
            return;
        }
        if (createPicker()) {
          pickerInitialized = true;
        }
      }

      function loadPickerScript() {
        if (pickerScriptLoaded) {
          return;
        }
        pickerScriptLoaded = true;
        const script = document.createElement('script');
        script.src = 'https://apis.google.com/js/api.js';
        script.async = true;
        script.onload = () => {
          if (!window.gapi) {
            pickerScriptLoaded = false;
            handlePickerError('Google API client failed to load.');
            return;
          }
          gapi.load('picker', { callback: onPickerApiLoad });
        };
        script.onerror = () => {
          pickerScriptLoaded = false;
          handlePickerError('Failed to load Google API script.');
        };
        document.head.appendChild(script);
      }

      function onPickerApiLoad() {
        pickerModuleReady = true;
        maybeCreatePicker();
      }

      let pickerInitialized = false;
      let pickerScriptLoaded = false;
      let pickerModuleReady = false;
      let currentFolderId = null;
      let isSelectingAll = false;

      window.addEventListener('resize', enforceFullScreen);

      // Show picker controls when picker is visible
      function showPickerControls() {
        if (PICKER_CONFIG.mode === 'files') {
          const controls = document.getElementById('picker-controls');
          if (controls) {
            controls.classList.add('visible');
          }
        }
      }

      function hidePickerControls() {
        const controls = document.getElementById('picker-controls');
        if (controls) {
          controls.classList.remove('visible');
        }
      }

      // Handle "Select All in Folder" button click
      async function handleSelectAllInFolder() {
        if (isSelectingAll) {
          return;
        }

        const btn = document.getElementById('select-all-btn');
        if (!btn) return;

        btn.classList.add('loading');
        isSelectingAll = true;

        try {
          // Get current folder ID from picker or use root
          const folderId = await getCurrentFolderId();
          
          if (!folderId) {
            throw new Error('Unable to determine current folder');
          }

          const folderName = folderId === 'root' ? 'My Drive' : 'current folder';
          console.log('üìÇ Fetching all audio files in', folderName, ':', folderId);

          // Fetch all audio files in the folder using Google Drive API
          const audioFiles = await fetchAllAudioFilesInFolder(folderId);

          if (audioFiles.length === 0) {
            showError(`No audio files found in ${folderName}.`);
            btn.classList.remove('loading');
            isSelectingAll = false;
            return;
          }

          console.log('‚úÖ Found', audioFiles.length, 'audio file(s) in', folderName);

          // Warn if too many files (may exceed URL length limit)
          const maxFilesForUrl = 15; // Approximate limit based on URL length
          if (audioFiles.length > maxFilesForUrl) {
            const proceed = confirm(
              `Found ${audioFiles.length} audio files. Selecting all may exceed URL length limits.\n\n` +
              `Consider selecting files in smaller batches (recommended: ${maxFilesForUrl} or fewer).\n\n` +
              `Do you want to proceed anyway?`
            );
            
            if (!proceed) {
              btn.classList.remove('loading');
              isSelectingAll = false;
              return;
            }
          }

          // Trigger selection callback with all files
          triggerFileSelection(audioFiles);

        } catch (error) {
          console.error('‚ùå Error selecting all files:', error);
          showError('Failed to select all files: ' + error.message);
        } finally {
          btn.classList.remove('loading');
          isSelectingAll = false;
        }
      }

      // Handle "Select All from My Drive" button click
      async function handleSelectAllFromDrive() {
        if (isSelectingAll) {
          return;
        }

        const btn = document.getElementById('select-all-drive-btn');
        if (!btn) return;

        btn.classList.add('loading');
        isSelectingAll = true;

        try {
          console.log('üìÇ Fetching all audio files from My Drive');

          // Fetch all audio files from root (My Drive)
          const audioFiles = await fetchAllAudioFilesInFolder('root');

          if (audioFiles.length === 0) {
            showError('No audio files found in My Drive.');
            btn.classList.remove('loading');
            isSelectingAll = false;
            return;
          }

          console.log('‚úÖ Found', audioFiles.length, 'audio file(s) in My Drive');

          // Warn if too many files (may exceed URL length limit)
          const maxFilesForUrl = 15; // Approximate limit based on URL length
          if (audioFiles.length > maxFilesForUrl) {
            const proceed = confirm(
              `Found ${audioFiles.length} audio files in My Drive. Selecting all may exceed URL length limits.\n\n` +
              `Consider selecting files in smaller batches (recommended: ${maxFilesForUrl} or fewer).\n\n` +
              `Do you want to proceed anyway?`
            );
            
            if (!proceed) {
              btn.classList.remove('loading');
              isSelectingAll = false;
              return;
            }
          }

          // Trigger selection callback with all files
          triggerFileSelection(audioFiles);

        } catch (error) {
          console.error('‚ùå Error selecting all files from My Drive:', error);
          showError('Failed to select all files: ' + error.message);
        } finally {
          btn.classList.remove('loading');
          isSelectingAll = false;
        }
      }

      // Update button text based on current folder
      function updateSelectAllButtonText() {
        const btn = document.getElementById('select-all-btn');
        const textEl = document.getElementById('select-all-text');
        
        if (btn && textEl) {
          if (currentFolderId && currentFolderId !== 'root') {
            textEl.textContent = 'Select All in Current Folder';
          } else {
            textEl.textContent = 'Select All in Folder';
          }
        }
      }

      // Detect folder navigation by monitoring picker DOM
      function detectFolderNavigation() {
        // Try to detect folder changes by monitoring the picker's internal state
        // This is a workaround since Google Picker doesn't expose current folder directly
        
        // Method 1: Monitor for folder clicks in the picker
        const observer = new MutationObserver((mutations) => {
          // Look for folder navigation indicators in the DOM
          const folderElements = document.querySelectorAll('[data-folder-id], [data-id]');
          folderElements.forEach(el => {
            el.addEventListener('click', (e) => {
              const folderId = el.getAttribute('data-folder-id') || el.getAttribute('data-id');
              if (folderId && folderId !== 'root') {
                currentFolderId = folderId;
                console.log('üìÇ Detected folder navigation to:', folderId);
              }
            });
          });
        });

        // Observe changes in the picker container
        const pickerContainer = document.querySelector('.picker-dialog, [role="dialog"]');
        if (pickerContainer) {
          observer.observe(pickerContainer, {
            childList: true,
            subtree: true
          });
        }

        // Method 2: Try to extract from URL or picker state
        // Check if we can get folder ID from the picker's internal state
        setTimeout(() => {
          // Look for breadcrumb or navigation elements
          const breadcrumbs = document.querySelectorAll('[class*="breadcrumb"], [class*="path"], [class*="folder"]');
          breadcrumbs.forEach(el => {
            const text = el.textContent || el.innerText;
            // Try to extract folder ID from various sources
            console.log('üîç Checking breadcrumb:', text);
          });
        }, 1000);
      }

      // Get current folder ID from picker (if possible) or use root
      async function getCurrentFolderId() {
        // If we have a stored folder ID, use it
        if (currentFolderId) {
          return currentFolderId;
        }

        // Try to get from picker's current view
        // Check if there's a way to get current folder from picker API
        // For now, we'll use 'root' which will fetch from "My Drive"
        console.log('üìÇ Using root folder (My Drive) - all audio files will be fetched');
        return 'root';
      }

      // Fetch all audio files in a folder using Google Drive API
      async function fetchAllAudioFilesInFolder(folderId) {
        const audioMimeTypes = [
          'audio/mpeg', 'audio/mp4', 'audio/x-m4a', 'audio/wav', 'audio/x-wav',
          'audio/flac', 'audio/x-flac', 'audio/aac', 'audio/ogg', 'audio/aiff', 'audio/x-aiff'
        ];

        const mimeTypeQuery = audioMimeTypes.map(mt => `mimeType='${mt}'`).join(' or ');
        
        // For root (My Drive), search all files owned by the user
        // For specific folders, search only files in that folder
        let query;
        if (folderId === 'root') {
          // Search all audio files in My Drive (owned by user)
          query = `(${mimeTypeQuery}) and trashed=false and 'me' in owners`;
        } else {
          // Search audio files in specific folder
          query = `(${mimeTypeQuery}) and '${folderId}' in parents and trashed=false`;
        }

        const baseUrl = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=nextPageToken,files(id,name,mimeType,parents)&pageSize=1000`;

        let allFiles = [];
        let nextPageToken = null;
        let pageCount = 0;
        const maxPages = 100; // Safety limit to prevent infinite loops

        do {
          const url = nextPageToken ? `${baseUrl}&pageToken=${nextPageToken}` : baseUrl;
          
          const response = await fetch(url, {
            headers: {
              'Authorization': `Bearer ${PICKER_CONFIG.accessToken}`
            }
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();
          const files = (data.files || []).map(file => ({
            id: file.id,
            name: file.name,
            mimeType: file.mimeType,
            parentId: file.parents && file.parents.length > 0 ? file.parents[0] : (folderId === 'root' ? 'root' : folderId)
          }));

          allFiles.push(...files);
          nextPageToken = data.nextPageToken;
          pageCount++;

          console.log(`üìÑ Fetched page ${pageCount}: ${files.length} files (total: ${allFiles.length})`);

          // Safety check
          if (pageCount >= maxPages) {
            console.warn(`‚ö†Ô∏è Reached maximum page limit (${maxPages}). Stopping pagination.`);
            break;
          }

        } while (nextPageToken);

        console.log(`‚úÖ Total files fetched: ${allFiles.length} from ${pageCount} page(s)`);
        return allFiles;
      }

      // Trigger file selection callback with the provided files
      function triggerFileSelection(files) {
        if (!files || files.length === 0) {
          return;
        }

        console.log('üéµ Triggering selection for', files.length, 'file(s)');

        // Build the same structure as the picker callback
        const filesData = files.map(file => ({
          id: file.id,
          name: file.name,
          mimeType: file.mimeType,
          parentId: file.parentId
        }));

        // Show selection status
        showSelectionStatus(files.length, files.length === 1 ? 'audio file selected' : 'audio files selected');

        // Process the selection the same way as picker callback
        if (callbackUrl.startsWith('ezgy://')) {
          const target = new URL(callbackUrl);
          const params = target.searchParams;
          params.set('action', 'files_picked');
          params.set('count', files.length.toString());

          filesData.forEach((file, index) => {
            params.set('id_' + index, file.id);
            if (file.name) {
              params.set('name_' + index, encodeURIComponent(file.name));
            }
            if (file.mimeType) {
              params.set('mime_' + index, file.mimeType);
            }
            if (file.parentId) {
              params.set('parent_' + index, file.parentId);
            }
          });

          const finalUrl = target.toString();
          console.log('üîµ Redirecting to deep link with', files.length, 'files');

          // Check URL length
          const maxUrlLength = 1800;
          if (finalUrl.length > maxUrlLength) {
            const errorMsg = `Too many files selected (${files.length} files). URL too long. Please select fewer files.`;
            handlePickerError(errorMsg);
            return;
          }

          try {
            window.location.href = finalUrl;
            setTimeout(function() {
              if (document.visibilityState === 'visible') {
                window.open(finalUrl, '_self');
              }
            }, 100);
          } catch (error) {
            console.error('‚ùå Error triggering deep link:', error);
            try {
              window.location.replace(finalUrl);
            } catch (e) {
              console.error('‚ùå Failed to trigger deep link:', e);
            }
          }
        } else {
          completeFlow('selected', {
            files: filesData,
            count: filesData.length
          });
        }
      }

      window.addEventListener('DOMContentLoaded', () => {
        ensureSignInElements();
        
        // Check if we have required config
        if (!PICKER_CONFIG.accessToken || PICKER_CONFIG.accessToken.length < 10) {
          showSignInOverlay();
          setSignInStatus('Loading Google Sign-In‚Ä¶');
    } else {
          // We have a token, proceed directly
          beginPickerFlow();
        }

        if (window.google?.accounts?.id) {
          initializeSignInButton();
        }
      });

      function onGisLoaded() {
        initializeSignInButton();
        // If we don't have a token, show sign-in overlay
        if (!PICKER_CONFIG.accessToken || PICKER_CONFIG.accessToken.length < 10) {
          showSignInOverlay('Please sign in to access Google Drive.');
        }
      }

      function onGisLoadError() {
        // If GIS fails to load but we have a token, try to proceed anyway
        if (PICKER_CONFIG.accessToken && PICKER_CONFIG.accessToken.length >= 10) {
          hideSignInOverlay();
          beginPickerFlow();
        } else {
          showSignInOverlay('Failed to load Google Sign-In. Refresh and try again.');
        }
      }

      window.onGisLoaded = onGisLoaded;
      window.onGisLoadError = onGisLoadError;
    </script>
    <script
      src="https://accounts.google.com/gsi/client"
      async
      defer
      onload="onGisLoaded()"
      onerror="onGisLoadError()"
    ></script>
  </head>
  <body>
    <div id="picker-root"></div>
    <div id="loader">
      <div class="spinner"></div>
      <div>Loading Google Picker‚Ä¶</div>
    </div>
    <div id="error-banner"></div>
    <div id="signin-overlay">
      <div id="signin-card">
        <h2>Connect your Google account</h2>
        <p>Sign in to pick folders from Google Drive.</p>
        <div id="signin-button"></div>
        <div id="signin-status"></div>
      </div>
    </div>
    <div id="selection-status"></div>
    <div id="picker-controls">
      <button class="picker-control-btn" id="select-all-btn" onclick="handleSelectAllInFolder()">
        <span class="icon">üéµ</span>
        <span class="text" id="select-all-text">Select All in Folder</span>
      </button>
      <button class="picker-control-btn" id="select-all-drive-btn" onclick="handleSelectAllFromDrive()">
        <span class="icon">üìÅ</span>
        <span class="text">Select All from My Drive</span>
      </button>
    </div>
</body>
</html>
